#+HTML_HEAD: <style>body { max-width: 80ex; margin: auto; font: 1.15em sans-serif; }</style>
#+TITLE: Documentation
* Data types
TWD has seven types. The types are text, number, boolean, date, regular
expression, item and /t/ set for any type /t/.
** Text
The syntax for a text string is ={text body}=, where =text body= can be any
string of characters. Matching pairs of curly braces inside the text body are
automatically escaped. To escape an unmatched closing curly brace, use a double
curly brace =}}=.
*** Predicates
| Operation      | Parameter | Result | Example            | Meaning                                     |
|----------------+-----------+--------+--------------------+---------------------------------------------|
| =:= (is)       | /text/    | /bool/ | =prop:{value}=     | =prop= is exactly "=value="                 |
| =/= (contains) | /text/    | /bool/ | =prop/{substring}= | =prop= contains "=substring="               |
| =<= (prefix)   | /text/    | /bool/ | =prop<{prefix}=    | =prop= starts with "=prefix="               |
| =>= (suffix)   | /text/    | /bool/ | =prop>{suffix}=    | =prop= ends with "=suffix="                 |
| =~= (matches)  | /regex/   | /bool/ | =prop~{regex}=     | =prop= matches regular expression "=regex=" |
*** Properties
| Operation | Type  | Result                             |
|-----------+-------+------------------------------------|
| =.length= | /num/ | Number of characters in the string |
** Item
(Missing documentation)
** Number
(Missing documentation.)
** Boolean
(Missing documentation.)
** Date
(Missing documentation.)
** Set
(Missing documentation.)

For some operation =.op= and a set =set= of /t/, the meaning of =set.op= depends
on the type of /op/. If op has type /t/ \to /u set/, then =set.op= will return
the union of =x.op= for each =x= in =set=, while =set&.op= will return the
intersection. Otherwise, =set*.op= for some operator =*= of type /(u, u) \to u/
will return the result of mapping each element =x= to =x.op= and reducing by
=*=.

1. =set.op= (op on t)
2. =set..op= (op on set)
3. =set*arg= (op on set)
4. =set.*arg= (op on t)
* Selections and filters
Some subset of all the items in the database is called a *selection*. Selections
are usually constructed by using *filters*.

TWD commands always act on the current selection. A command in TWD takes the
form
#+BEGIN_EXAMPLE
> [filter] [command] [arguments]
#+END_EXAMPLE
where =[filter]= is a filter that changes the selection, =[command]= is the name
of a command that will act on that selection, and =[arguments]= may be a list of
arguments given to the command.

The command /list/ simply lists all of the items in the current selection; it
does not take arguments. If no command is specified, /list/ is the default. This
means that typing a filter on the command line will list all items in the
database matching that filter.
** List of filter properties
*** Global ID (=id=)
*Type:* text\\

The simplest possible filter simply specifies the global ID of a single task;
for example, the task with global ID /a4/ is written =id:{a4}=:
#+BEGIN_EXAMPLE
> id:a4
 # | ID | Desc
---+----+---------------
 1 | 4v | Do the dishes
#+END_EXAMPLE
*** Description (=description=)
*Type:* text\\

This is the default property; when no property is specified, /description/ is
assumed. For example, to list all items whose description contains "buy":
#+BEGIN_EXAMPLE
> /buy
  | Description
--+------------------
1 | Buy milk
2 | Buy chocolate
3 | Decide which car to buy
#+END_EXAMPLE
(This command is equivalent to =desc/{buy} list=.)
Note that simply typing =example= will not list all items whose description
exactly matches "example", because this could be confused with the name of a
command; instead, use either ={example}= or =:example= to abbreviate
=description:{example}=.
*** All tags (=tags=)
*Type:* set of text\\

(Missing documentation.)
*** Any tag (=tag=)
*Type:* text\\

(Missing documentation.)
*** Active (=active=)
*Type:* boolean\\

This property is on if the item is active (meaning it can be completed) and off
if it is inactive.
*** Completed (=done=)
*Type:* boolean\\

This property is on if the item has been marked as completed and off otherwise.
*** Base urgency (=baseurgency=)
*Type:* number\\

The base urgency of an item is the urgency that has been manually assigned to
that item. The =urgency= property is a read-only property that is computed from
the base urgency after taking into account various other factors.
*** Urgency (=urgency=)
*Type:* number\\

(Missing documentation.)
** Filter property types
Each filter property has a type. The types are /text/, /date/, /number/, /item/
and /set/. Each type supports various prediates.
*** Text
Note that all of the text predicates are case insensitive by default.

*Supported prediates:*
| Operation         | Example            | Meaning                                     |
|-------------------+--------------------+---------------------------------------------|
| =:= (is)          | =prop:{value}=     | =prop= is exactly "=value="                 |
| =/= (contains)    | =prop/{substring}= | =prop= contains "=substring="               |
| =<= (starts with) | =prop<{prefix}=    | =prop= starts with "=prefix="               |
| =>= (ends with)   | =prop>{suffix}=    | =prop= ends with "=suffix="                 |
| =~= (matches)     | =prop~{regex}=     | =prop= matches regular expression "=regex=" |
*** Boolean
*Supported prediates:*
| Operation    | Example | Meaning       |
|--------------+---------+---------------|
| =+= (has)    | =+prop= | =prop= is on  |
| =-= (hasn't) | =-prop= | =prop= is off |
*** Date
(Missing documentation.)
*** Number
(Missing documentation.)
*** Item
(Missing documentation.)
*** Set
(Missing documentation.)
** Filter operators
Filter operators can be used to modify and compose filters. Operators can be
unary or binary.
*** Unary operators
Most unary operators are written as =filter .operator=. Note
that parentheses can be used to specify how the operator binds to its argument,
and that spacing influences this as well. For example, the following commands
are equivalent:
#+BEGIN_EXAMPLE
> ((!#a, !#b).dep).not, #c
> !#a, !#b .dep.not, #c
#+END_EXAMPLE
Some unary operators can be written using prefix syntax. For example, =A.not=
can also be written =!A=.
**** Invert (=not=)
*Arity:* unary\\
*Alias:* =!= (prefix)\\

This operator inverts the filter argument; that is, it selects all items that do
not match the filter. For example, the equivalent commands
#+BEGIN_EXAMPLE
> #cleaning (/wash, /wash.blocks).not
#+END_EXAMPLE
shows all items that are tagged with "cleaning", but which do not contain the
word "wash" or are blocking a task containing the word "wash". The same command
can be written using the prefix form of the =not= operator, which is called =!=:
#+BEGIN_EXAMPLE
> #cleaning !(/wash, /wash.b)
#+END_EXAMPLE
**** Dependencies (=depends=)
*Arity:* unary\\
*Alias:* =dep=, =d=\\

The operation /depends/ gives all the items that are (directly) dependent on any
of the items matching a given filter. It is the opposite operation of /blocks/.

For example, the following command adds the tag "maybe" to dependencies of tasks
that are already tagged "maybe":
#+BEGIN_EXAMPLE
> #maybe .dep mod #maybe
#+END_EXAMPLE
**** Blocking (=blocks=)
*Arity:* unary\\
*Alias*: =blo=, =b=\\

The operation /blocks/ gives all the items that are (directly) blocking any of
the items matching a given filter. It is the opposite operation of /depends/.

For example, the following command adds the tag "soon" to the tasks that are
blocking a task that is either tagged with "design" or which begin with the word
"consider":
#+BEGIN_EXAMPLE
> #design, <consider .blo mod #soon
#+END_EXAMPLE
*** Binary operators
Binary operators are written in infix notation.
**** Intersection (space)
*Arity:* binary\\
*Alias:* --- \\

When two filters are written next to each other with spaces between them, this
operator is used to combine the two filters.

The result of =A B= is the set of items that match both filters =A= and =B=. For
example, the following returns all items that are tagged "reading", but which
are not tagged "research":
#+BEGIN_EXAMPLE
> #reading !#research
#+END_EXAMPLE
**** Union (=,=)
*Arity:* binary\\
*Alias:* --- \\

The result of =A, B= is the set of items that match the filter =A= /or/ the
filter =B=. For example, the following command lists all items which depend on
an item that is either active or tagged as "soon":
#+BEGIN_EXAMPLE
> (+active, #soon).depends
#+END_EXAMPLE
** Local ids and listing references
When listing the items matching a certain filter, the output looks like this:
#+BEGIN_EXAMPLE
> @week #important list
A | Tags                    | Due | Description
--+-------------------------+-----+--------------------------------
1 | #important #research    | mon | Research bobcats
2 | #important #appointment | tue | Meeting with Bob about bobcats
3 | #important              | tue | Send documentation
4 | #important              | fri | Respond to Jane's email
#+END_EXAMPLE
Note the letter "A" in leftmost column of the header. This is called the
*listing reference*. When used in a filter, this reference represents all of the
items in that listing. For example, the command below narrows the above
selection to the tasks that are due later than monday and which don't contain
the word "send":
#+BEGIN_EXAMPLE
> A due>mon !/send
B | Tags                    | Due | Description
--+-------------------------+-----+--------------------------------
1 | #important #appointment | tue | Meeting with Bob about bobcats
2 | #important              | fri | Respond to Jane's email
#+END_EXAMPLE
Note that the listing reference has changed to "B". The listing reference will
cycle through the letters A-Z. Also note the numbers in the leftmost column;
these are the *local ids* of each item. These numbers can be used to refer to an
item inside of a filter. For example, this command shows the second item in the
listing of =@week #important 2= (i.e. "Meeting with Bob about bobcats"), as well
as any items tagged "research":
#+BEGIN_EXAMPLE
> @week #important 2, @none #research
C | Tags                    | Due | Description
--+-------------------------+-----+--------------------------------
1 | #important #research    | mon | Research bobcats
2 | #research               |     | Figure out why penguins can't fly
3 | #important #appointment | tue | Meeting with Bob about bobcats
#+END_EXAMPLE
Most commonly, local ids are used together with listing references to refer to
an item from an earlier listing. Thus, the previous command could also take
advantage of the listing labeled "A", shortening it it to:
#+BEGIN_EXAMPLE
> A 2, #research
#+END_EXAMPLE
As a special abbreviation, the space between the reference and the id may be
omitted. For example:
#+BEGIN_EXAMPLE
> A4, B1
B | Tags                    | Due | Description
--+-------------------------+-----+--------------------------------
1 | #important #appointment | tue | Meeting with Bob about bobcats
2 | #important              | fri | Respond to Jane's email
#+END_EXAMPLE
* Contexts
It is possible to activate any number of different *contexts*. A context
specifies the default filter, as well as a list of properties that will be
automatically added to newly created items. Contexts can either be enabled or
disabled globally, or they can be set for a single command. It is possible to
enable multiple contexts at the same time.

To cretae a new context, use the command =context new [filter] (default
[properties])= (the default part is optional). The following will create a
context called "leisure" in which only items that are tagged with "fun" as well
as items that are active, due and whose urgency exceeds 10 are shown, and where
items are given the property =review:tomorrow= by default:
#+BEGIN_EXAMPLE
> context add leisure #fun, (+active due<=now urgency>=10) default review:tomorrow
#+END_EXAMPLE
To active the context, use =context enable=:
#+BEGIN_EXAMPLE
> context enable leisure
#+END_EXAMPLE
It is possible to override the current contexts for a single command by
prefixing the context name with the =@= character. Contexts stack in the order
they are given, while the special context =@none= disables all contexts. For
instance, the following command enables the contexts "appointments" and
"important" in addition to any contexts that are already enabled:
#+BEGIN_EXAMPLE
> @appointments @important list
#+END_EXAMPLE
This command adds a new item without using any of the default properties from
currently enabled contexts:
#+BEGIN_EXAMPLE
> @none add #shopping {Buy groceries} due:tomorrow@17:00
#+END_EXAMPLE
* Commands
** List selection (=list=)
This is the default command.
** Modify selection (=modify=)
(Missing documentation.)
*** Arguments
(Missing documentation.)
** Add task (=add=)
(Missing documentation.)
** Evaluating expressions (=eval=)
(Missing documentation.)
